# js函数
函数即对象（函数名保存的是指向函数对象的指针），每个函数都是Function类型的实例，而且与其他引用类型一样拥有属性和方法

1 内部两个特殊的对象arguments和this
+ arguments:是一个类数组对象，主要用途是保存函数的参数，拥有一个callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数，可以用来实现递归调用中函数体内代码与函数名解耦，即arguments.callee()==函数名
+ this引用的是函数执行的函数变量（当在网页全局作用域中调用函数的时候，this对象引用的就是window）

另一个函数对象的属性caller(es5规范定义的)：保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null

2 函数属性和方法
+ length:函数希望接收到的命名参数的个数
+ prototype：包含着引用类型所有实例方法的真真所在，在es5中，他是不可枚举的。

每个函数都会包含两个非继承而来的方法apply()和call(),这两个方法的主要作用就是在特定的作用域中调用函数，实际上等于设置函数内部this对象的值，主要用途：扩充函数赖以运行的作用域
+ apply()：包含两个参数第一个参数是运行函数的作用域，第二个参数是参数数组（Array类型的实列或auguments对象）
+ call(): 第一个参数同上，第二个参数都是直接传递给函数（一个个列举）
+ es5定义了一个方法 bind():创建一个函数的实例，其this值会被绑定到传给bind()函数的参数值

列如：
```js
window.color = "red";
var o = {color:"blue"};
function sayColor(){
    alert(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor();//blue
```
3 基本包装类型（特殊的引用类型）

Boolean,String,Number这三种基本类型在被读取的时候，后台会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。与引用类型的主要区别是：对象的生存期，由new操作符创建的实例在执行流离开当前作用域之前一直保存在内存中，而自动创建的基本包装类型对象，则只存在于一行代码的执行瞬间，然后被立即销毁